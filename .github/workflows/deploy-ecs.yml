name: Reusable ECS Deployment Workflow

on:
  workflow_call:
    inputs:
      service_name:
        description: "Service name (e.g., 'pdf', 'email', 'notification')"
        required: true
        type: string
      service_display_name:
        description: "Display name for the service"
        required: false
        type: string
      aws_region:
        description: "AWS region"
        required: false
        type: string
        default: "eu-west-2"
      main_branch:
        description: "Main/production branch name"
        required: false
        type: string
        default: "main"
      staging_branch:
        description: "Staging branch name"
        required: false
        type: string
        default: "stage"
      environment:
        description: "Environment override (for workflow_dispatch) - optional"
        required: false
        type: string
      branch:
        description: "Branch override (for workflow_dispatch) - optional"
        required: false
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  setup:
    name: Determine Environment and Configuration
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      branch: ${{ steps.set-env.outputs.branch }}
      aws_region: ${{ steps.set-env.outputs.aws_region }}
      ecr_repository: ${{ steps.set-env.outputs.ecr_repository }}
      ecs_service: ${{ steps.set-env.outputs.ecs_service }}
      ecs_cluster: ${{ steps.set-env.outputs.ecs_cluster }}
      version: ${{ steps.version-check.outputs.version }}
      is_release: ${{ steps.version-check.outputs.is_release }}
      has_tag: ${{ steps.version-check.outputs.has_tag }}
      aws_role_to_assume: ${{ steps.set-env.outputs.aws_role_to_assume }}
      slack_webhook_url: ${{ steps.set-env.outputs.slack_webhook_url }}

    steps:
      - name: Set environment variables
        id: set-env
        run: |
          # Determine environment and branch based on trigger
          if [[ -n "${{ inputs.environment }}" ]]; then
            # Manual workflow_dispatch with environment specified
            ENV="${{ inputs.environment }}"
            if [[ -n "${{ inputs.branch }}" ]]; then
              BRANCH="${{ inputs.branch }}"
            else
              BRANCH="${{ github.ref_name }}"
            fi
          elif [[ "${{ github.ref }}" == "refs/heads/${{ inputs.main_branch }}" ]]; then
            ENV="production"
            BRANCH="${{ inputs.main_branch }}"
          elif [[ "${{ github.ref }}" == "refs/heads/${{ inputs.staging_branch }}" ]]; then
            ENV="staging"
            BRANCH="${{ inputs.staging_branch }}"
          else
            echo "Error: Unexpected branch ${{ github.ref }}"
            exit 1
          fi

          # Set environment-specific values
          if [[ "$ENV" == "production" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "aws_region=${{ inputs.aws_region }}" >> $GITHUB_OUTPUT
            echo "ecr_repository=prod-${{ inputs.service_name }}-service" >> $GITHUB_OUTPUT
            echo "ecs_service=prod-${{ inputs.service_name }}-service" >> $GITHUB_OUTPUT
            echo "ecs_cluster=prod-fargate-cluster" >> $GITHUB_OUTPUT
            echo "aws_role_to_assume=${{ secrets.AWS_ROLE_TO_ASSUME_PROD }}" >> $GITHUB_OUTPUT
            echo "slack_webhook_url=${{ secrets.SLACK_WEBHOOK_URL_PROD }}" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "aws_region=${{ inputs.aws_region }}" >> $GITHUB_OUTPUT
            echo "ecr_repository=stage-${{ inputs.service_name }}-service" >> $GITHUB_OUTPUT
            echo "ecs_service=stage-${{ inputs.service_name }}-service" >> $GITHUB_OUTPUT
            echo "ecs_cluster=stage-fargate-cluster" >> $GITHUB_OUTPUT
            echo "aws_role_to_assume=${{ secrets.AWS_ROLE_TO_ASSUME_STAGING }}" >> $GITHUB_OUTPUT
            echo "slack_webhook_url=${{ secrets.SLACK_WEBHOOK_URL_STAGING }}" >> $GITHUB_OUTPUT
          fi

          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

      - name: Checkout code for version check
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ steps.set-env.outputs.branch }}

      - name: Check version and tags
        id: version-check
        run: |
          # Get version from package.json if it exists
          if [ -f "package.json" ]; then
            VERSION=$(grep '"version"' package.json | sed -E 's/.*"version":\s*"([^"]*)".*/\1/')
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Version: $VERSION"
            
            # Check if this is a release (commit message contains version bump)
            COMMIT_MESSAGE=$(git log -1 --pretty=%B)
            if [[ "$COMMIT_MESSAGE" =~ "chore: bump version to" ]] || [[ "$COMMIT_MESSAGE" =~ "chore: release version" ]]; then
              echo "is_release=true" >> $GITHUB_OUTPUT
              echo "ðŸŽ‰ This is a release deployment"
              
              # For release deployments to production, wait for tag (REQUIRED)
              if [[ "${{ steps.set-env.outputs.environment }}" == "production" ]] && [[ "${{ github.event_name }}" == "push" ]]; then
                echo "â³ Waiting for tag v$VERSION to be created (required for production releases)..."
                
                # Wait up to 30 seconds for the tag to appear (should be quick)
                TAG_FOUND=false
                for i in {1..10}; do
                  git fetch --tags
                  if git rev-parse "v$VERSION" >/dev/null 2>&1; then
                    echo "âœ… Tag v$VERSION found!"
                    echo "has_tag=true" >> $GITHUB_OUTPUT
                    TAG_FOUND=true
                    break
                  fi
                  echo "Waiting for tag... ($i/10)"
                  sleep 3
                done
                
                # For production releases, tag is REQUIRED
                if [ "$TAG_FOUND" = false ]; then
                  echo "âŒ ERROR: Tag v$VERSION was not created after 30 seconds!"
                  echo "This is a release deployment to production, but the tagging workflow appears to have failed."
                  echo "Please check the tag-release workflow logs and ensure it completed successfully."
                  echo ""
                  echo "Possible issues:"
                  echo "  - The PR might not have had the 'release' label"
                  echo "  - The tag-release workflow might have failed"
                  echo "  - There might be a permissions issue"
                  echo ""
                  echo "Deployment cannot proceed without a proper tag for production releases."
                  exit 1
                fi
              else
                # For non-release or staging deployments, tag is optional
                git fetch --tags
                if git rev-parse "v$VERSION" >/dev/null 2>&1; then
                  echo "has_tag=true" >> $GITHUB_OUTPUT
                  echo "ðŸ“Œ Tag v$VERSION exists"
                else
                  echo "has_tag=false" >> $GITHUB_OUTPUT
                  echo "ðŸ“Œ No tag for v$VERSION (OK for staging/non-release)"
                fi
              fi
            else
              # Not a release deployment - tag is optional
              echo "is_release=false" >> $GITHUB_OUTPUT
              echo "ðŸ“¦ Regular deployment"
              
              # Check if a tag exists anyway
              git fetch --tags
              if git rev-parse "v$VERSION" >/dev/null 2>&1; then
                echo "has_tag=true" >> $GITHUB_OUTPUT
                echo "ðŸ“Œ Tag v$VERSION exists"
              else
                echo "has_tag=false" >> $GITHUB_OUTPUT
                echo "ðŸ“Œ No tag for v$VERSION"
              fi
            fi
          else
            echo "version=unknown" >> $GITHUB_OUTPUT
            echo "is_release=false" >> $GITHUB_OUTPUT
            echo "has_tag=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ No package.json found, version unknown"
          fi

  build-and-deploy:
    name: Build and Deploy to ${{ needs.setup.outputs.environment }}
    needs: setup
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.branch }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.setup.outputs.aws_role_to_assume }}
          aws-region: ${{ needs.setup.outputs.aws_region }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        id: build-image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ needs.setup.outputs.ecr_repository }}:latest
            ${{ steps.login-ecr.outputs.registry }}/${{ needs.setup.outputs.ecr_repository }}:${{ github.sha }}
            ${{ needs.setup.outputs.version != 'unknown' && format('{0}/{1}:{2}', steps.login-ecr.outputs.registry, needs.setup.outputs.ecr_repository, needs.setup.outputs.version) || '' }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/arm64
          provenance: false

      - name: Get current task definition
        id: task-def
        run: |
          TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ needs.setup.outputs.ecs_cluster }} \
            --services ${{ needs.setup.outputs.ecs_service }} \
            --region ${{ needs.setup.outputs.aws_region }} \
            --query 'services[0].taskDefinition' \
            --output text)
          echo "task-definition=$TASK_DEF" >> $GITHUB_OUTPUT
          echo "Current task definition: $TASK_DEF"

      - name: Register new task definition
        id: register-task-def
        run: |
          # Get the current task definition JSON
          TASK_DEF_JSON=$(aws ecs describe-task-definition \
            --task-definition ${{ steps.task-def.outputs.task-definition }} \
            --region ${{ needs.setup.outputs.aws_region }} \
            --query 'taskDefinition' \
            --output json)

          # Extract the image from the current task definition
          CURRENT_IMAGE=$(echo "$TASK_DEF_JSON" | jq -r '.containerDefinitions[0].image')
          echo "Current image: $CURRENT_IMAGE"

          # Build the new image tag (use commit SHA)
          IMAGE_REPO=$(echo "$CURRENT_IMAGE" | sed 's/:.*//')
          NEW_IMAGE_TAG="${{ github.sha }}"
          NEW_IMAGE="$IMAGE_REPO:$NEW_IMAGE_TAG"
          echo "New image: $NEW_IMAGE"

          # Remove fields that can't be included in register-task-definition
          TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')

          # Update the image in the task definition
          TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --arg IMAGE "$NEW_IMAGE" '.containerDefinitions[0].image = $IMAGE')

          # Register the new task definition
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json "$TASK_DEF_JSON" \
            --region ${{ needs.setup.outputs.aws_region }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "task-definition=$NEW_TASK_DEF" >> $GITHUB_OUTPUT
          echo "âœ… Registered new task definition: $NEW_TASK_DEF"

      - name: Update ECS service
        run: |
          aws ecs update-service \
            --cluster ${{ needs.setup.outputs.ecs_cluster }} \
            --service ${{ needs.setup.outputs.ecs_service }} \
            --task-definition ${{ steps.register-task-def.outputs.task-definition }} \
            --region ${{ needs.setup.outputs.aws_region }}

      - name: Wait for service stability
        run: |
          aws ecs wait services-stable \
            --cluster ${{ needs.setup.outputs.ecs_cluster }} \
            --services ${{ needs.setup.outputs.ecs_service }} \
            --region ${{ needs.setup.outputs.aws_region }}

      - name: Create deployment summary
        if: always()
        run: |
          echo "## ðŸš€ ${{ inputs.service_display_name }} Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Environment: ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.setup.outputs.version }}" != "unknown" ]]; then
            if [[ "${{ needs.setup.outputs.has_tag }}" == "true" ]]; then
              echo "- **Version:** v${{ needs.setup.outputs.version }} ðŸ·ï¸" >> $GITHUB_STEP_SUMMARY
            else
              echo "- **Version:** ${{ needs.setup.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            fi
            if [[ "${{ needs.setup.outputs.is_release }}" == "true" ]]; then
              echo "- **Type:** ðŸŽ‰ Release Deployment" >> $GITHUB_STEP_SUMMARY
            else
              echo "- **Type:** Regular Deployment" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          echo "- **Branch:** ${{ needs.setup.outputs.branch }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ECR Repository:** ${{ needs.setup.outputs.ecr_repository }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Service:** ${{ needs.setup.outputs.ecs_service }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Cluster:** ${{ needs.setup.outputs.ecs_cluster }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Task Definition:** ${{ steps.register-task-def.outputs.task-definition }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AWS Region:** ${{ needs.setup.outputs.aws_region }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "âœ… **${{ needs.setup.outputs.environment }} deployment completed successfully!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **${{ needs.setup.outputs.environment }} deployment failed!**" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Send deployment notification
        if: always() && needs.setup.outputs.slack_webhook_url != ''
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            ${{ inputs.service_display_name }} Deployment: ${{ job.status }}
            Environment: ${{ needs.setup.outputs.environment }}
            ${{ needs.setup.outputs.version != 'unknown' && format('Version: {0}{1}', needs.setup.outputs.has_tag == 'true' && 'v' || '', needs.setup.outputs.version) || '' }} ${{ needs.setup.outputs.is_release == 'true' && 'ðŸŽ‰' || '' }}
            Branch: ${{ needs.setup.outputs.branch }}
            Commit: ${{ github.sha }}
        env:
          SLACK_WEBHOOK_URL: ${{ needs.setup.outputs.slack_webhook_url }}
